#if 0
	shc Version 3.9.3a3, Generic Shell Script Compiler
	GNU GPL Version 3 Fedor Mankov <envieidoc@gmail.com>

	./shc -v -r -f io_build.command 
#endif

static  char data [] = 
#define      text_z	533
#define      text	((&data[123]))
	"\046\232\213\174\366\127\111\366\042\070\075\022\077\343\245\174"
	"\063\024\342\106\024\175\165\303\077\254\013\314\270\100\230\135"
	"\301\040\166\071\265\230\205\004\343\354\151\203\105\155\200\002"
	"\135\314\031\366\006\370\120\377\265\110\153\025\012\266\000\005"
	"\067\213\372\170\056\267\277\233\337\010\360\235\127\174\247\367"
	"\267\374\260\027\375\202\017\366\045\077\001\006\242\155\260\234"
	"\103\275\167\234\261\066\236\362\231\011\152\247\333\250\112\053"
	"\010\024\234\202\314\104\307\015\362\340\325\162\311\237\324\344"
	"\335\113\112\105\104\160\374\047\316\014\042\315\147\257\123\143"
	"\324\011\253\003\226\351\221\142\101\334\132\217\316\032\220\044"
	"\033\363\077\173\373\351\334\013\231\037\053\320\070\102\124\303"
	"\241\254\037\200\012\077\110\304\107\064\035\152\067\234\372\177"
	"\006\331\044\012\007\276\110\120\066\072\031\322\104\114\170\110"
	"\235\066\144\346\211\352\035\165\212\170\001\312\343\075\251\365"
	"\276\230\307\130\342\370\257\252\006\327\300\313\127\057\310\305"
	"\224\044\355\336\326\066\241\311\013\354\165\111\051\022\016\035"
	"\320\070\133\240\112\072\174\311\277\054\314\263\154\350\174\141"
	"\054\040\273\271\343\331\067\136\126\207\256\371\332\366\077\074"
	"\044\060\205\362\163\256\165\157\075\221\214\202\254\146\307\070"
	"\003\274\241\013\332\247\127\231\061\117\255\246\021\274\363\237"
	"\256\313\022\227\314\237\263\252\146\315\303\156\027\220\302\340"
	"\227\135\034\277\046\355\325\246\135\346\204\162\040\103\324\015"
	"\244\125\261\035\201\256\145\177\341\140\376\326\063\137\061\375"
	"\370\222\074\352\313\233\314\011\205\150\062\132\053\070\342\340"
	"\316\165\071\054\203\102\202\375\042\073\230\066\300\134\166\346"
	"\035\306\376\365\217\110\121\221\116\271\364\210\235\072\263\343"
	"\371\170\066\060\111\121\110\321\211\153\127\236\077\221\231\053"
	"\303\225\256\161\352\334\316\315\165\224\362\255\324\167\154\234"
	"\132\145\257\076\333\131\245\334\030\327\127\107\302\003\012\267"
	"\171\041\273\142\320\046\007\104\235\333\326\364\156\126\353\140"
	"\067\316\054\170\052\167\320\005\113\260\035\366\214\240\005\233"
	"\116\037\233\332\307\141\376\305\114\260\231\112\021\337\003\235"
	"\020\120\212\110\135\076\311\170\267\337\352\147\124\045\355\224"
	"\201\307\354\337\240\013\103\134\375\012\257\165\015\271\031\144"
	"\313\147\360\015\241\063\054\066\264\364\152\027\372\235\256\326"
	"\071\335\253\350\217\036\121\267\165\101\372\121\115\303\152\067"
	"\125\031\270\150\134\172\222\141\112\176\072\371\221\236\121\356"
	"\051\045\162\002\161\365\320\134\030\207\224\141\054\065\123\045"
	"\356\356\221\322\330\062\010\340\153\110\001\354\310\335\270\300"
	"\150\310\206\115\143\162\236\053\230\244\336\145\016\003\367\102"
	"\163\240\274\326\107\057\227\104\102\253\232\243\103\146\121\140"
	"\301\260\035\060\302\042\141\121\241\157\227\300\304\267\026\255"
	"\330\356\114\336\337\315\041\107\365\342\217\042\063\003\230\256"
	"\046\071\126\336\012\077\327\000\175\136\244\137\231\276\005\334"
	"\327\125\153\303\366\361\315\163\220\164\357\175\230\246\262\210"
	"\124\044\066\111\311\256\070\251\007\231\054\345\207\001\144\172"
	"\133\200\126\070\144\325\017\060\105\146\326\352\257\125\343\113"
	"\017\260\044\306\313\300\310\365\113\174\007\257\321\223\365\026"
	"\007\160"
#define      date_z	1
#define      date	((&data[770]))
	"\326"
#define      pswd_z	256
#define      pswd	((&data[812]))
	"\377\100\376\271\041\330\265\031\131\177\145\302\027\204\217\270"
	"\071\077\200\057\157\035\226\331\064\263\110\303\270\332\036\310"
	"\305\240\147\023\243\312\125\166\050\315\053\306\112\136\332\313"
	"\357\366\166\317\237\167\254\206\113\122\357\253\015\236\020\357"
	"\003\002\342\270\323\022\345\164\032\240\234\171\041\351\242\213"
	"\143\277\046\333\074\166\025\111\201\160\376\125\170\251\251\167"
	"\143\221\000\247\357\164\332\173\201\155\033\201\043\227\300\232"
	"\224\250\130\223\267\110\171\260\372\001\246\366\166\153\047\206"
	"\222\276\105\273\324\144\142\077\203\171\303\111\065\266\223\031"
	"\101\316\104\070\362\160\025\145\101\370\100\226\304\141\154\237"
	"\336\050\352\342\112\246\234\024\321\314\251\333\220\132\136\113"
	"\056\140\214\376\251\106\231\037\223\303\337\045\014\117\045\064"
	"\220\266\034\231\336\244\160\013\260\172\374\253\225\020\246\034"
	"\216\120\172\075\135\243\103\231\105\163\121\352\055\104\356\251"
	"\365\334\351\364\164\260\105\272\252\342\330\054\165\362\164\344"
	"\235\020\073\060\257\350\131\243\344\207\012\124\165\153\220\146"
	"\111\073\133\221\071\253\031\375\043\306\051\373\031\175\171\066"
	"\013\022\342\133\056\335\056\205\135\235\167\125\013\340\120\027"
	"\326\024\326\356\345\075\375\014\064\140\175\050\062\272\331\262"
	"\117\012\177\176\303\354\173\110\217\252\272\273"
#define      lsto_z	1
#define      lsto	((&data[1087]))
	"\265"
#define      inlo_z	3
#define      inlo	((&data[1088]))
	"\022\311\030"
#define      msg1_z	62
#define      msg1	((&data[1098]))
	"\260\363\230\203\067\327\227\254\235\365\245\006\235\126\345\117"
	"\031\015\101\166\210\352\025\076\071\312\376\230\342\051\066\345"
	"\222\073\041\214\364\030\066\273\311\123\302\226\013\116\175\362"
	"\223\125\205\120\026\041\264\352\256\371\060\032\224\117\264\131"
	"\066\124\101\347\230"
#define      msg2_z	19
#define      msg2	((&data[1164]))
	"\210\102\010\377\305\262\075\166\243\220\312\247\204\343\177\175"
	"\255\251\371\150\233\103\073\034\372"
#define      tst1_z	22
#define      tst1	((&data[1186]))
	"\036\342\340\116\227\154\223\106\143\207\146\150\047\264\035\201"
	"\116\357\324\321\321\163\007\325\335\277"
#define      shll_z	10
#define      shll	((&data[1211]))
	"\145\073\134\343\113\345\042\303\175\336"
#define      rlax_z	1
#define      rlax	((&data[1221]))
	"\172"
#define      xecc_z	15
#define      xecc	((&data[1225]))
	"\375\344\115\321\251\265\306\361\361\363\030\023\261\322\005\363"
	"\313\352\226\353"
#define      opts_z	1
#define      opts	((&data[1242]))
	"\246"
#define      chk1_z	22
#define      chk1	((&data[1245]))
	"\140\205\300\234\052\214\212\267\176\053\314\374\330\012\260\271"
	"\206\120\137\132\064\304\021\212\171\212\060\247\031"
#define      tst2_z	19
#define      tst2	((&data[1275]))
	"\312\207\270\114\150\365\353\046\254\070\074\312\325\003\205\201"
	"\342\356\346\055\123\172\237\005\262\020"
#define      chk2_z	19
#define      chk2	((&data[1301]))
	"\034\034\045\202\244\253\310\325\136\232\065\127\330\276\076\027"
	"\275\173\207\343\371\145"/* End of data[] */;
#define      hide_z	4096
#define DEBUGEXEC	0	/* Define as 1 to debug execvp calls */
#define TRACEABLE	1	/* Define as 1 to enable ptrace the executable */
#define BUSYBOXON	0	/* Define as 1 to enable work with busybox */

/* rtc.c */

#include <sys/stat.h>
#include <sys/types.h>

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <unistd.h>

/* 'Alleged RC4' */

static unsigned char stte[256], indx, jndx, kndx;

/*
 * Reset arc4 stte. 
 */
void stte_0(void)
{
	indx = jndx = kndx = 0;
	do {
		stte[indx] = indx;
	} while (++indx);
}

/*
 * Set key. Can be used more than once. 
 */
void key(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		do {
			tmp = stte[indx];
			kndx += tmp;
			kndx += ptr[(int)indx % len];
			stte[indx] = stte[kndx];
			stte[kndx] = tmp;
		} while (++indx);
		ptr += 256;
		len -= 256;
	}
}

/*
 * Crypt data. 
 */
void arc4(void * str, int len)
{
	unsigned char tmp, * ptr = (unsigned char *)str;
	while (len > 0) {
		indx++;
		tmp = stte[indx];
		jndx += tmp;
		stte[indx] = stte[jndx];
		stte[jndx] = tmp;
		tmp += stte[indx];
		*ptr ^= stte[tmp];
		ptr++;
		len--;
	}
}

/* End of ARC4 */

/*
 * Key with file invariants. 
 */
int key_with_file(char * file)
{
	struct stat statf[1];
	struct stat control[1];

	if (stat(file, statf) < 0)
		return -1;

	/* Turn on stable fields */
	memset(control, 0, sizeof(control));
	control->st_ino = statf->st_ino;
	control->st_dev = statf->st_dev;
	control->st_rdev = statf->st_rdev;
	control->st_uid = statf->st_uid;
	control->st_gid = statf->st_gid;
	control->st_size = statf->st_size;
	control->st_mtime = statf->st_mtime;
	control->st_ctime = statf->st_ctime;
	key(control, sizeof(control));
	return 0;
}

#if DEBUGEXEC
void debugexec(char * sh11, int argc, char ** argv)
{
	int i;
	fprintf(stderr, "shll=%s\n", sh11 ? sh11 : "<null>");
	fprintf(stderr, "argc=%d\n", argc);
	if (!argv) {
		fprintf(stderr, "argv=<null>\n");
	} else { 
		for (i = 0; i <= argc ; i++)
			fprintf(stderr, "argv[%d]=%.60s\n", i, argv[i] ? argv[i] : "<null>");
	}
}
#endif /* DEBUGEXEC */

void rmarg(char ** argv, char * arg)
{
	for (; argv && *argv && *argv != arg; argv++);
	for (; argv && *argv; argv++)
		*argv = argv[1];
}

int chkenv(int argc)
{
	char buff[512];
	unsigned long mask, m;
	int l, a, c;
	char * string;
	extern char ** environ;

	mask  = (unsigned long)&chkenv;
	mask ^= (unsigned long)getpid() * ~mask;
	sprintf(buff, "x%lx", mask);
	string = getenv(buff);
#if DEBUGEXEC
	fprintf(stderr, "getenv(%s)=%s\n", buff, string ? string : "<null>");
#endif
	l = strlen(buff);
	if (!string) {
		/* 1st */
		sprintf(&buff[l], "=%lu %d", mask, argc);
		putenv(strdup(buff));
		return 0;
	}
	c = sscanf(string, "%lu %d%c", &m, &a, buff);
	if (c == 2 && m == mask) {
		/* 3rd */
		rmarg(environ, &string[-l - 1]);
		return 1 + (argc - a);
	}
	return -1;
}

#if !TRACEABLE

#define _LINUX_SOURCE_COMPAT
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <fcntl.h>
#include <signal.h>
#include <stdio.h>
#include <unistd.h>

#if !defined(PTRACE_ATTACH) && defined(PT_ATTACH)
#	define PTRACE_ATTACH	PT_ATTACH
#endif
void untraceable(char * argv0)
{
	char proc[80];
	int pid, mine;

	switch(pid = fork()) {
	case  0:
		pid = getppid();
		/* For problematic SunOS ptrace */
#if defined(__FreeBSD__)
		sprintf(proc, "/proc/%d/mem", (int)pid);
#else
		sprintf(proc, "/proc/%d/as",  (int)pid);
#endif
		close(0);
		mine = !open(proc, O_RDWR|O_EXCL);
		if (!mine && errno != EBUSY)
			mine = !ptrace(PTRACE_ATTACH, pid, 0, 0);
		if (mine) {
			kill(pid, SIGCONT);
		} else {
			perror(argv0);
			kill(pid, SIGKILL);
		}
		_exit(mine);
	case -1:
		break;
	default:
		if (pid == waitpid(pid, 0, 0))
			return;
	}
	perror(argv0);
	_exit(1);
}
#endif /* !TRACEABLE */

char * xsh(int argc, char ** argv)
{
	char * scrpt;
	int ret, i, j;
	char ** varg;
	char * me = getenv("_");
	if (me == NULL) { me = argv[0]; }

	stte_0();
	 key(pswd, pswd_z);
	arc4(msg1, msg1_z);
	arc4(date, date_z);
	if (date[0] && (atoll(date)<time(NULL)))
		return msg1;
	arc4(shll, shll_z);
	arc4(inlo, inlo_z);
	arc4(xecc, xecc_z);
	arc4(lsto, lsto_z);
	arc4(tst1, tst1_z);
	 key(tst1, tst1_z);
	arc4(chk1, chk1_z);
	if ((chk1_z != tst1_z) || memcmp(tst1, chk1, tst1_z))
		return tst1;
	ret = chkenv(argc);
	arc4(msg2, msg2_z);
	if (ret < 0)
		return msg2;
	varg = (char **)calloc(argc + 10, sizeof(char *));
	if (!varg)
		return 0;
	if (ret) {
		arc4(rlax, rlax_z);
		if (!rlax[0] && key_with_file(shll))
			return shll;
		arc4(opts, opts_z);
		arc4(text, text_z);
		arc4(tst2, tst2_z);
		 key(tst2, tst2_z);
		arc4(chk2, chk2_z);
		if ((chk2_z != tst2_z) || memcmp(tst2, chk2, tst2_z))
			return tst2;
		/* Prepend hide_z spaces to script text to hide it. */
		scrpt = malloc(hide_z + text_z);
		if (!scrpt)
			return 0;
		memset(scrpt, (int) ' ', hide_z);
		memcpy(&scrpt[hide_z], text, text_z);
	} else {			/* Reexecute */
		if (*xecc) {
			scrpt = malloc(512);
			if (!scrpt)
				return 0;
			sprintf(scrpt, xecc, me);
		} else {
			scrpt = me;
		}
	}
	j = 0;
#if BUSYBOXON
	varg[j++] = "busybox";
	varg[j++] = "sh";
#else
	varg[j++] = argv[0];		/* My own name at execution */
#endif
	if (ret && *opts)
		varg[j++] = opts;	/* Options on 1st line of code */
	if (*inlo)
		varg[j++] = inlo;	/* Option introducing inline code */
	varg[j++] = scrpt;		/* The script itself */
	if (*lsto)
		varg[j++] = lsto;	/* Option meaning last option */
	i = (ret > 1) ? ret : 0;	/* Args numbering correction */
	while (i < argc)
		varg[j++] = argv[i++];	/* Main run-time arguments */
	varg[j] = 0;			/* NULL terminated array */
#if DEBUGEXEC
	debugexec(shll, j, varg);
#endif
	execvp(shll, varg);
	return shll;
}

int main(int argc, char ** argv)
{
#if DEBUGEXEC
	debugexec("main", argc, argv);
#endif
#if !TRACEABLE
	untraceable(argv[0]);
#endif
	argv[1] = xsh(argc, argv);
	fprintf(stderr, "%s%s%s: %s\n", argv[0],
		errno ? ": " : "",
		errno ? strerror(errno) : "",
		argv[1] ? argv[1] : "<null>"
	);
	return 1;
}
